1.键盘输入
Scanner sc = new Scanner(System.in);
int x = sc.nextInt();//这个根据类型更改比如String Char ..
sc.hasNext();返回的是boolean类型，即存在或者不存在

2.String
基本数据类型：字符型Char,Boolean型,数值型：byte8、short16、long64、int32、float32、double64
下面是节本类型的包装类，即该基本类型的一些参数和方法
byte 			Byte
short			Short
int				Integer
long			Long
float			Float
double			Double
char			Character
boolean			Boolean
字符串截取 String s = new String(s1,n,m);
如果放入字节例如byte[] bys = {97,98,99}  String s = new String(bys);会变成a,b,c
字符串一旦被赋值能不能被改变
 字符串如果是变量相加，先开空间，在拼接；字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建  例如String s1 = "hello" String s2 = "world" String s3 = "helloworld" s3!=s1+s2 但是s3 == "helloworld"
编码问题:byte --> String:string(byte[] bys,String charSetName) String --> byte getBytes(String charSetName)


3.Array
在Algorithm中有Sort.java排序算法
当对于字符进行排序的时候，先将字符串转化成字符数组Char[] chs = s.toCharArray();，然后用算法排序，然后将得到的字符数组转换成字符串 String s = String.valueOf(chs);

排序后如果想找一个具体数值的位置可以使用直接查找(一个一个遍历)，或者二分查找binarySearch（这个是本身的API，源码中调用的是DualPivotQuicksort即快速排序）(找出中位数的value和要找的数对比，小于min = mid+1，大于max = mid-1),注意二分查找要注意在加一个判断一旦min > max return -1;即退出
4.Character
判断是否是字符是否是大写数字小写，在密码校验中，但是一般用正则；isUpperCase isLowerCase isDigit 将is换成to可以转换
可以通过遍历判断进行大写小写和数字的统计

5.Integer
int 和 String转换：1.String --》int Integer.parseInt(s) 2.int --> String String.toString(int);
进制转化：
十进制转其他：Integer.toBinaryString();注意返回的是String
其他转十进制：Integer.ParseInt(String,int(进制数))

Integer = 100;这是对的，因为在JDK5之后引入自动拆装箱，即将100作为字符进行处理 装：Integer.valueOf() 拆箱：Integer.intValue()
针对-128到127之间的数据，做了一个数据缓冲池，如果数据是该范围内的，每次并不创建新的空间
Integer i1 = 128 Integer i2 = 128 i1!=i2 但是如果是127等号成立

6.StringBuffer(线程安全即同步的可变字符串)
StringBuffer是同步的，数据安全,效率低;StringBuilder是不同步的,数据不安全,效率高
对于StringBuffer和String来说，前者是不固定的，所以在进行字符串拼接append；删除delete还可以指定位置；替换replace可以指定位置；翻转reverse，不会浪费资源
String --> StringBuffer 直接使用StringBuffer的构造方法；StringBuffer --> String toString
将数组拼接字符串：1.直接使用String 2.使用StringBuffer进行拼接
StringBuffer和数组的区别：都是容器但是数组中放置多种数据但是必须是同一种，StringBuffer最终是字符串类型
形式参数，如果是基本类型，改变不影响实际参数；引用类型改变影响参数，注意String作为参数传递，效果和基本类型作为参数传递是一样的

7.BigDecimal
BigDecimal类：不可变的、任意精度的有符号十进制数,可以解决精度丢失问题
add、subtract、multiply、divide

8.BigInteger
对超过Integer（-2147483647--2147483647）范围的整数操作
divideAndRemainder得到含有商和余数的数组

9.Calendar
Calendar rightNow = Calendar.getInstance();
通过get方法和静态参数可以得到year,month(从0开始的),day
判断某一年的二月有多少天：1.得到日历对象2.设置c.set(year,2,1)即那一年的3.1号，然后将day减一天c.add(Claendar.DATE,-1)3.c.get(Claendar.DATE)

10.DateFormat
System.currentTimeMillis()系统现在的毫秒时间
Date --》 String：SimpleDateFormat.format(Date对象) ，这个将Date按照创建SimpleDateFormat对象构造方法中指定的构造得到字符串
String --》 Date：SimpleDateFormat.parse(String对象)得到的是Date对象，这里的String需要和创建SimpleDateFormat对象构造方法中的字符结构相同

11.Math
Math方法 .abs 绝对值 ; ceil 向上取整 ; floor 向下取整;；pow(a,b) a的b次方 ; random 随机数 ; max 最大数; round 四舍五入 ; sqrt 平方根
Math成员变量 PI E

12.正则表达式
A:字符
	x 字符 x。举例：'a'表示字符a
	\\ 反斜线字符。两个才能代表一个
	\n 新行（换行）符 ('\u000A') 
	\r 回车符 ('\u000D')
	
B:字符类
	[abc] a、b 或 c（简单类） 
	[^abc] 任何字符，除了 a、b 或 c（否定） 
	[a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） 
	[0-9] 0到9的字符都包括
	
C:预定义字符类
	. 任何字符。我的就是.字符本身，怎么表示呢? \.
	\d 数字：[0-9]
	\w 单词字符：[a-zA-Z_0-9]
		在正则表达式里面组成单词的东西必须有这些东西组成

D:边界匹配器
	^ 行的开头 
	$ 行的结尾 
	\b 单词边界
		就是不是单词字符的地方。
		举例：hello world?haha;xixi
	
E:Greedy 数量词 
	X? X，一次或一次也没有
	X* X，零次或多次
	X+ X，一次或多次
	X{n} X，恰好 n 次 
	X{n,} X，至少 n 次 
	X{n,m} X，至少 n 次，但是不超过 m 次 	
s.matches(String regex);邮箱验证: \\w@\\w{2,6}\\.\\w{2,3} 标准：所有字符[a-zA-Z_0-9]@所有字符最小2位最大6位.所有字符只能是2或者3位
s.replace(regex,String replaceMent)将符合正则形式的替换成给的字符串
Pattern p = Pattern.compile(regex);//将规则编译成模式对象
Matcher m = p.matcher(s);//通过模式对象得到匹配器对象


13.集合
由于数组是固定长度的，而StringBuffer虽然可伸缩但是返回的是字符串
数组和集合的区别:1.长度区别2.内容区别:数组是同一种类型元素,集合可以存储不同种元素3.数据类型:数组可以存储基本数据类型和引用数据类型,集合只能存储引用类型
Collection(是接口不能实例化，需要其子类；注意和Collections的区分，Collections是针对集合的操作类例如排序和二分查找，当对于自定义对象的时候需要在方法中定义匿名内部类) 、addAll(Collection),removeAll(Collection)移除一个元素就返回true,containsAll(Collection),retainAll(Collection)两个集合都有的元素，最终保存在A中B不变  返回的是boolean类型
--》 List可重复,有顺序,特有迭代listIterator(继承Iterator)特有previous()获得上一个元素、hasPrevious()判断是否有元素 
	-->ArrayList(底层是数组，查找快，增删慢、线程不安全效率高)；去除ArrayList中的重复项，可以创建一个新的数组存储，也可以通过遍历使前后元素比较，类似于排序；如果数组里是自定义对象而不是引用对象时，这时候不能用equals而是contains(底层依赖但是重写equals())
	-->Vector(底层是数组，查找快，增删慢、线程安全效率低)
	-->LinkedList(底层是链表，查找慢，增删快、线程不安全效率高)特有addFirst(),getFirst(),removeFirst()这个得到的是最先存入的可以使用这个方法实现栈的先进先出的结构,  add,remove,get,set
--》 Set  无序但是不重复
	--> HashSet 存储字符串的时候内容相同只存储一个，add依赖的hashCode()和equals()方法重写了；；当add的是自定义的对象的时候，如果想避免add()重复对象，可以在POJO类重写hashCode和equals方法
		-->LinkedHashSet:底层数据结构由Hash表和链表结构组成，存储和取出一致
	--> TreeSet 红黑树实现，能够使自定义对象唯一且排序(自然排序;比较器排序:自定义对象需要实现Comparable<>接口，实现其中的compareTo方法***当然可以不实现接口而是在创建TreeSet的时候实现匿名内部类(这个类还是要实现Comparator<>接口，实现其中的compare方法))
		
迭代:1、C.toArray()可以将集合转换成数组(Arrays.asList()可以将集合转换成数组)，用于实现集合的遍历 2、迭代器迭代遍历Collection c = new Collection(); Iterator it = c.iterator(); while(it.hasNext()){String s = (String)it.next()} 这里的String可以换成其他引用对象
泛型的好处：将在运行时的问题提前、可以避免强制转换,有时会在接口对象创建上使用泛型 public class Interface<T>{public abstract T get(T t){}};在类方法用public<T> void  show(T t){}
泛型高级嫁娶通配符: <? extends 类> E及E的子类  <? super E>E及E的父类
增强for的目标不能是null可以加入if判断

Map 键唯一值不唯一 put添加元素 values获得全部值(Collection<>) 获得全部的键keySet()(返回Set<>)
--》HashMap 用哈希表保证键的唯一性 ，线程不安全，效率高。允许null键和null值   ,Hashtable与之相反        HashMap里包含ArrayList，其中用keySet获得key的Set<>集合，然后遍历两次得到ArrayList的value;ArrayList中包含HashMap<key,value>时先遍历在用keySet获得key集合，再得到value
	-->LinkedHashMap 实现Map接口的哈希表(保证唯一)和链接列表(保证存储和取出顺序一致)的实现，可以可预知迭代顺序
--》TreeMap 红黑树实现
14.静态导入、可变参数：例如不知道导入几个参数int... a这里的a其实相当于一个数组，可以通过遍历得到每一个参数

15.Throwable error-->例如内存溢出 、Exception-->RuntimeException
处理方法-->try{}catch(异常名 变量 ){必须有内容}可以多catch但是父子关系，父必须放在后面，Catch内的异常也可以是多个但是必须同级 e.toString e.getMessage()可以帮助我们了解错误类型finally{}    final、finally和finalize的区别？ final是关键字可以修饰成员变量(常量)、成员方法(不能被重写)、类(不能被继承),finally是释放资源，除非未执行到finallyJVM推出不然肯定执行，如果在catch中有return那么肯定执行finally在return 之前,finalize用于垃圾回收
	-->throws 与throw区别  throws用在方法声明之后，可以是多个方法类名；throw方法体重，一旦使用一定抛出异常
自定义Exception需要继承Exception或者RuntimeException ,子类重写父类，子类方法只能抛出和父类一样或者其子类的异常

16.File
File(String pathname)、File(parentpath,path)、File(File,chilepath) 注意这里的String的\符号都需要\\转译过去
File.createFile()如果存在这样的文件不会创建该文件  mkdir()创建文件夹，如果存在不创建  mkdirs()如果父文件夹不存在会帮你创建，如果不写父文件夹默认是项目文件夹  删除delete文件夹中不能有东西，且不走回收站  重命名renameTo(File dest)如果路径相同为重命名，如果路径不同为剪切
getPath()得到相对路径  getAbsolutePath()得到绝对路径 getModified()获取最后修改时间 list()获得所有的文件及文件夹的名字string[]  获得文件File[]用listFiles(new FilenameFilter(){accept方法})里卖弄可以写匿名内部类过滤文件

17.递归
递归一定要有出口不然为死递归，递归太多容易内存溢出，构造方法不能递归使用;递归删除，递归得到文件名，递归树

18.IO 主动，输出即写，读取即读;注意流的回收一般在try catch finally中的finally中执行.close()
-->字节流 OutputStream InputStream 
	--》 xxxOutputStream(File.、Buffered.高效) ..实现上面的抽象类的子类xxx对应的是操作对象,例如File writer(xxx)注意里面是字节会自动转换 其中的换行操作同样需要.getBytes()转换成字节，Windows为\r\n linux为\n mac为\r;操作中文会出乱码;指定编码和解码的类型 InputStreamReader(new FileInputStream(""),"UTF-8")
	--》xxxInputStream byte[] bys = new byte[]; int len =0; while((len = fis.read(bys))!=-1) {System.out.println(new String(bys,0,len))} fis.close();
-->字符流        Writer    Reader
	--》OutputStreamWriter write(int char[] char[],0,len String String,0,n) 注意在写的时候需要flush()刷新缓存区才能写到;flush()和close()的区别:flush只是刷新缓存区，刷新后的流对象还可以继续使用，而close()方法先刷新缓冲区再关闭流对象，不能使用
	--》InputStreamReader char[] chs = new char[1024];
	--》FIleReader = FileInputStream + 编码表(GBK)
	--》BufferedWriter new BufferedWriter(new FileWriter("path"));
	--》BufferedReader 除了char[] chs = new char[1024];还有读取的特殊方法newline()根据系统换行符string line = null;while((BUfferedReader.readLine())!=-1){}
	注意BufferedWriter和BufferedReader在读写或者写读的时候创建对象需要分开用的时候在创建
复制数据，如果我们知道用记事本打开并能够读懂，就用字符流，否则用字节流