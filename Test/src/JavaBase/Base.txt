1.键盘输入
Scanner sc = new Scanner(System.in);
int x = sc.nextInt();//这个根据类型更改比如String Char ..
sc.hasNext();返回的是boolean类型，即存在或者不存在

2.String
基本数据类型：字符型Char,Boolean型,数值型：byte8、short16、long64、int32、float32、double64
下面是节本类型的包装类，即该基本类型的一些参数和方法
byte 			Byte
short			Short
int				Integer
long			Long
float			Float
double			Double
char			Character
boolean			Boolean
字符串截取 String s = new String(s1,n,m);
如果放入字节例如byte[] bys = {97,98,99}  String s = new String(bys);会变成a,b,c
字符串一旦被赋值能不能被改变
 字符串如果是变量相加，先开空间，在拼接；字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建  例如String s1 = "hello" String s2 = "world" String s3 = "helloworld" s3!=s1+s2 但是s3 == "helloworld"

3.Array
在Algorithm中有Sort.java排序算法
当对于字符进行排序的时候，先将字符串转化成字符数组Char[] chs = s.toCharArray();，然后用算法排序，然后将得到的字符数组转换成字符串 String s = String.valueOf(chs);

排序后如果想找一个具体数值的位置可以使用直接查找(一个一个遍历)，或者二分查找binarySearch（这个是本身的API，源码中调用的是DualPivotQuicksort即快速排序）(找出中位数的value和要找的数对比，小于min = mid+1，大于max = mid-1),注意二分查找要注意在加一个判断一旦min > max return -1;即退出
4.Character
判断是否是字符是否是大写数字小写，在密码校验中，但是一般用正则；isUpperCase isLowerCase isDigit 将is换成to可以转换
可以通过遍历判断进行大写小写和数字的统计

5.Integer
int 和 String转换：1.String --》int Integer.parseInt(s) 2.int --> String String.toString(int);
进制转化：
十进制转其他：Integer.toBinaryString();注意返回的是String
其他转十进制：Integer.ParseInt(String,int(进制数))

Integer = 100;这是对的，因为在JDK5之后引入自动拆装箱，即将100作为字符进行处理 装：Integer.valueOf() 拆箱：Integer.intValue()
针对-128到127之间的数据，做了一个数据缓冲池，如果数据是该范围内的，每次并不创建新的空间
Integer i1 = 128 Integer i2 = 128 i1!=i2 但是如果是127等号成立

6.StringBuffer(线程安全即同步的可变字符串)
StringBuffer是同步的，数据安全,效率低;StringBuilder是不同步的,数据不安全,效率高
对于StringBuffer和String来说，前者是不固定的，所以在进行字符串拼接append；删除delete还可以指定位置；替换replace可以指定位置；翻转reverse，不会浪费资源
String --> StringBuffer 直接使用StringBuffer的构造方法；StringBuffer --> String toString
将数组拼接字符串：1.直接使用String 2.使用StringBuffer进行拼接
StringBuffer和数组的区别：都是容器但是数组中放置多种数据但是必须是同一种，StringBuffer最终是字符串类型
形式参数，如果是基本类型，改变不影响实际参数；引用类型改变影响参数，注意String作为参数传递，效果和基本类型作为参数传递是一样的

7.BigDecimal
BigDecimal类：不可变的、任意精度的有符号十进制数,可以解决精度丢失问题
add、subtract、multiply、divide

8.BigInteger
对超过Integer（-2147483647--2147483647）范围的整数操作
divideAndRemainder得到含有商和余数的数组

9.Calendar
Calendar rightNow = Calendar.getInstance();
通过get方法和静态参数可以得到year,month(从0开始的),day
判断某一年的二月有多少天：1.得到日历对象2.设置c.set(year,2,1)即那一年的3.1号，然后将day减一天c.add(Claendar.DATE,-1)3.c.get(Claendar.DATE)

10.DateFormat
System.currentTimeMillis()系统现在的毫秒时间
Date --》 String：SimpleDateFormat.format(Date对象) ，这个将Date按照创建SimpleDateFormat对象构造方法中指定的构造得到字符串
String --》 Date：SimpleDateFormat.parse(String对象)得到的是Date对象，这里的String需要和创建SimpleDateFormat对象构造方法中的字符结构相同

11.Math
Math方法 .abs 绝对值 ; ceil 向上取整 ; floor 向下取整;；pow(a,b) a的b次方 ; random 随机数 ; max 最大数; round 四舍五入 ; sqrt 平方根
Math成员变量 PI E

12.正则表达式
A:字符
	x 字符 x。举例：'a'表示字符a
	\\ 反斜线字符。两个才能代表一个
	\n 新行（换行）符 ('\u000A') 
	\r 回车符 ('\u000D')
	
B:字符类
	[abc] a、b 或 c（简单类） 
	[^abc] 任何字符，除了 a、b 或 c（否定） 
	[a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） 
	[0-9] 0到9的字符都包括
	
C:预定义字符类
	. 任何字符。我的就是.字符本身，怎么表示呢? \.
	\d 数字：[0-9]
	\w 单词字符：[a-zA-Z_0-9]
		在正则表达式里面组成单词的东西必须有这些东西组成

D:边界匹配器
	^ 行的开头 
	$ 行的结尾 
	\b 单词边界
		就是不是单词字符的地方。
		举例：hello world?haha;xixi
	
E:Greedy 数量词 
	X? X，一次或一次也没有
	X* X，零次或多次
	X+ X，一次或多次
	X{n} X，恰好 n 次 
	X{n,} X，至少 n 次 
	X{n,m} X，至少 n 次，但是不超过 m 次 	
s.matches(String regex);邮箱验证: \\w@\\w{2,6}\\.\\w{2,3} 标准：所有字符[a-zA-Z_0-9]@所有字符最小2位最大6位.所有字符只能是2或者3位
s.replace(regex,String replaceMent)将符合正则形式的替换成给的字符串
Pattern p = Pattern.compile(regex);//将规则编译成模式对象
Matcher m = p.matcher(s);//通过模式对象得到匹配器对象


13.集合
由于数组是固定长度的，而StringBuffer虽然可伸缩但是返回的是字符串
数组和集合的区别:1.长度区别2.内容区别:数组是同一种类型元素,集合可以存储不同种元素3.数据类型:数组可以存储基本数据类型和引用数据类型,集合只能存储引用类型
Collection(是接口不能实例化，需要其子类；注意和Collections的区分，Collections是针对集合的操作类例如排序和二分查找，当对于自定义对象的时候需要在方法中定义匿名内部类) 、addAll(Collection),removeAll(Collection)移除一个元素就返回true,containsAll(Collection),retainAll(Collection)两个集合都有的元素，最终保存在A中B不变  返回的是boolean类型
--》 List可重复,有顺序,特有迭代listIterator(继承Iterator)特有previous()获得上一个元素、hasPrevious()判断是否有元素 
	-->ArrayList(底层是数组，查找快，增删慢、线程不安全效率高)；去除ArrayList中的重复项，可以创建一个新的数组存储，也可以通过遍历使前后元素比较，类似于排序；如果数组里是自定义对象而不是引用对象时，这时候不能用equals而是contains(底层依赖但是重写equals())
	-->Vector(底层是数组，查找快，增删慢、线程安全效率低)
	-->LinkedList(底层是链表，查找慢，增删快、线程不安全效率高)特有addFirst(),getFirst(),removeFirst()这个得到的是最先存入的可以使用这个方法实现栈的先进先出的结构,  add,remove,get,set
--》 Set  无序但是不重复
	--> HashSet 存储字符串的时候内容相同只存储一个，add依赖的hashCode()和equals()方法重写了；；当add的是自定义的对象的时候，如果想避免add()重复对象，可以在POJO类重写hashCode和equals方法
		-->LinkedHashSet:底层数据结构由Hash表和链表结构组成，存储和取出一致
	--> TreeSet 能够使自定义对象唯一且排序(自然排序;比较器排序:自定义对象需要实现Comparable<>接口，实现其中的compareTo方法***当然可以不实现接口而是在创建TreeSet的时候实现匿名内部类(这个类还是要实现Comparator<>接口，实现其中的compare方法))
		
迭代:1、C.toArray()可以将集合转换成数组(Arrays.asList()可以将集合转换成数组)，用于实现集合的遍历 2、迭代器迭代遍历Collection c = new Collection(); Iterator it = c.iterator(); while(it.hasNext()){String s = (String)it.next()} 这里的String可以换成其他引用对象
泛型的好处：将在运行时的问题提前、可以避免强制转换,有时会在接口对象创建上使用泛型 public class Interface<T>{public abstract T get(T t){}};在类方法用public<T> void  show(T t){}
泛型高级嫁娶通配符: <? extends 类> E及E的子类  <? super E>E及E的父类
增强for的目标不能是null可以加入if判断

Map 键唯一值不唯一 put添加元素 values获得全部值(Collection<>) 获得全部的键keySet()(返回Set<>)
--》HashMap 用哈希表保证键的唯一性
	-->LinkedHashMap 

14.静态导入、可变参数：例如不知道导入几个参数int... a这里的a其实相当于一个数组，可以通过遍历得到每一个参数


