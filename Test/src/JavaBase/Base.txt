1.键盘输入
Scanner sc = new Scanner(System.in);
int x = sc.nextInt();//这个根据类型更改比如String Char ..
sc.hasNext();返回的是boolean类型，即存在或者不存在

2.String
基本数据类型：字符型Char,Boolean型,数值型：byte8、short16、long64、int32、float32、double64
下面是节本类型的包装类，即该基本类型的一些参数和方法
byte 			Byte
short			Short
int				Integer
long			Long
float			Float
double			Double
char			Character
boolean			Boolean
字符串截取 String s = new String(s1,n,m);
如果放入字节例如byte[] bys = {97,98,99}  String s = new String(bys);会变成a,b,c
字符串一旦被赋值能不能被改变
 字符串如果是变量相加，先开空间，在拼接；字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建  例如String s1 = "hello" String s2 = "world" String s3 = "helloworld" s3!=s1+s2 但是s3 == "helloworld"
编码问题:byte --> String:string(byte[] bys,String charSetName) String --> byte getBytes(String charSetName)


3.Array
在Algorithm中有Sort.java排序算法
当对于字符进行排序的时候，先将字符串转化成字符数组Char[] chs = s.toCharArray();，然后用算法排序，然后将得到的字符数组转换成字符串 String s = String.valueOf(chs);

排序后如果想找一个具体数值的位置可以使用直接查找(一个一个遍历)，或者二分查找binarySearch（这个是本身的API，源码中调用的是DualPivotQuicksort即快速排序）(找出中位数的value和要找的数对比，小于min = mid+1，大于max = mid-1),注意二分查找要注意在加一个判断一旦min > max return -1;即退出
4.Character
判断是否是字符是否是大写数字小写，在密码校验中，但是一般用正则；isUpperCase isLowerCase isDigit 将is换成to可以转换
可以通过遍历判断进行大写小写和数字的统计

5.Integer
int 和 String转换：1.String --》int Integer.parseInt(s) 2.int --> String String.toString(int);
进制转化：
十进制转其他：Integer.toBinaryString();注意返回的是String
其他转十进制：Integer.ParseInt(String,int(进制数))

Integer = 100;这是对的，因为在JDK5之后引入自动拆装箱，即将100作为字符进行处理 装：Integer.valueOf() 拆箱：Integer.intValue()
针对-128到127之间的数据，做了一个数据缓冲池，如果数据是该范围内的，每次并不创建新的空间
Integer i1 = 128 Integer i2 = 128 i1!=i2 但是如果是127等号成立

6.StringBuffer(线程安全即同步的可变字符串)
StringBuffer是同步的，数据安全,效率低;StringBuilder是不同步的,数据不安全,效率高
对于StringBuffer和String来说，前者是不固定的，所以在进行字符串拼接append；删除delete还可以指定位置；替换replace可以指定位置；翻转reverse，不会浪费资源
String --> StringBuffer 直接使用StringBuffer的构造方法；StringBuffer --> String toString
将数组拼接字符串：1.直接使用String 2.使用StringBuffer进行拼接
StringBuffer和数组的区别：都是容器但是数组中放置多种数据但是必须是同一种，StringBuffer最终是字符串类型
形式参数，如果是基本类型，改变不影响实际参数；引用类型改变影响参数，注意String作为参数传递，效果和基本类型作为参数传递是一样的

7.BigDecimal
BigDecimal类：不可变的、任意精度的有符号十进制数,可以解决精度丢失问题
add、subtract、multiply、divide

8.BigInteger
对超过Integer（-2147483647--2147483647）范围的整数操作
divideAndRemainder得到含有商和余数的数组

9.Calendar
Calendar rightNow = Calendar.getInstance();
通过get方法和静态参数可以得到year,month(从0开始的),day
判断某一年的二月有多少天：1.得到日历对象2.设置c.set(year,2,1)即那一年的3.1号，然后将day减一天c.add(Claendar.DATE,-1)3.c.get(Claendar.DATE)

10.DateFormat
System.currentTimeMillis()系统现在的毫秒时间
Date --》 String：SimpleDateFormat.format(Date对象) ，这个将Date按照创建SimpleDateFormat对象构造方法中指定的构造得到字符串
String --》 Date：SimpleDateFormat.parse(String对象)得到的是Date对象，这里的String需要和创建SimpleDateFormat对象构造方法中的字符结构相同

11.Math
Math方法 .abs 绝对值 ; ceil 向上取整 ; floor 向下取整;；pow(a,b) a的b次方 ; random 随机数 ; max 最大数; round 四舍五入 ; sqrt 平方根
Math成员变量 PI E

12.正则表达式
A:字符
	x 字符 x。举例：'a'表示字符a
	\\ 反斜线字符。两个才能代表一个
	\n 新行（换行）符 ('\u000A') 
	\r 回车符 ('\u000D')
	
B:字符类
	[abc] a、b 或 c（简单类） 
	[^abc] 任何字符，除了 a、b 或 c（否定） 
	[a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） 
	[0-9] 0到9的字符都包括
	
C:预定义字符类
	. 任何字符。我的就是.字符本身，怎么表示呢? \.
	\d 数字：[0-9]
	\w 单词字符：[a-zA-Z_0-9]
		在正则表达式里面组成单词的东西必须有这些东西组成

D:边界匹配器
	^ 行的开头 
	$ 行的结尾 
	\b 单词边界
		就是不是单词字符的地方。
		举例：hello world?haha;xixi
	
E:Greedy 数量词 
	X? X，一次或一次也没有
	X* X，零次或多次
	X+ X，一次或多次
	X{n} X，恰好 n 次 
	X{n,} X，至少 n 次 
	X{n,m} X，至少 n 次，但是不超过 m 次 	
s.matches(String regex);邮箱验证: \\w@\\w{2,6}\\.\\w{2,3} 标准：所有字符[a-zA-Z_0-9]@所有字符最小2位最大6位.所有字符只能是2或者3位
s.replace(regex,String replaceMent)将符合正则形式的替换成给的字符串
Pattern p = Pattern.compile(regex);//将规则编译成模式对象
Matcher m = p.matcher(s);//通过模式对象得到匹配器对象


13.集合
由于数组是固定长度的，而StringBuffer虽然可伸缩但是返回的是字符串
数组和集合的区别:1.长度区别2.内容区别:数组是同一种类型元素,集合可以存储不同种元素3.数据类型:数组可以存储基本数据类型和引用数据类型,集合只能存储引用类型
Collection(是接口不能实例化，需要其子类；注意和Collections的区分，Collections是针对集合的操作类例如排序和二分查找，当对于自定义对象的时候需要在方法中定义匿名内部类) 、addAll(Collection),removeAll(Collection)移除一个元素就返回true,containsAll(Collection),retainAll(Collection)两个集合都有的元素，最终保存在A中B不变  返回的是boolean类型
--》 List可重复,有顺序,特有迭代listIterator(继承Iterator)特有previous()获得上一个元素、hasPrevious()判断是否有元素 
	-->ArrayList(底层是数组，查找快，增删慢、线程不安全效率高)；去除ArrayList中的重复项，可以创建一个新的数组存储，也可以通过遍历使前后元素比较，类似于排序；如果数组里是自定义对象而不是引用对象时，这时候不能用equals而是contains(底层依赖但是重写equals())
	-->Vector(底层是数组，查找快，增删慢、线程安全效率低)
	-->LinkedList(底层是链表，查找慢，增删快、线程不安全效率高)特有addFirst(),getFirst(),removeFirst()这个得到的是最先存入的可以使用这个方法实现栈的先进先出的结构,  add,remove,get,set
--》 Set  无序但是不重复
	--> HashSet 存储字符串的时候内容相同只存储一个，add依赖的hashCode()和equals()方法重写了；；当add的是自定义的对象的时候，如果想避免add()重复对象，可以在POJO类重写hashCode和equals方法
		-->LinkedHashSet:底层数据结构由Hash表和链表结构组成，存储和取出一致
	--> TreeSet 红黑树实现，能够使自定义对象唯一且排序(自然排序;比较器排序:自定义对象需要实现Comparable<>接口，实现其中的compareTo方法***当然可以不实现接口而是在创建TreeSet的时候实现匿名内部类(这个类还是要实现Comparator<>接口，实现其中的compare方法))
		
迭代:1、C.toArray()可以将集合转换成数组(Arrays.asList()可以将集合转换成数组)，用于实现集合的遍历 2、迭代器迭代遍历Collection c = new Collection(); Iterator it = c.iterator(); while(it.hasNext()){String s = (String)it.next()} 这里的String可以换成其他引用对象
泛型的好处：将在运行时的问题提前、可以避免强制转换,有时会在接口对象创建上使用泛型 public class Interface<T>{public abstract T get(T t){}};在类方法用public<T> void  show(T t){}
泛型高级嫁娶通配符: <? extends 类> E及E的子类  <? super E>E及E的父类
增强for的目标不能是null可以加入if判断

Map 键唯一值不唯一 put添加元素 values获得全部值(Collection<>) 获得全部的键keySet()(返回Set<>)
--》HashMap 用哈希表保证键的唯一性 ，线程不安全，效率高。允许null键和null值   ,Hashtable与之相反        HashMap里包含ArrayList，其中用keySet获得key的Set<>集合，然后遍历两次得到ArrayList的value;ArrayList中包含HashMap<key,value>时先遍历在用keySet获得key集合，再得到value
	-->LinkedHashMap 实现Map接口的哈希表(保证唯一)和链接列表(保证存储和取出顺序一致)的实现，可以可预知迭代顺序
--》TreeMap 红黑树实现
14.静态导入、可变参数：例如不知道导入几个参数int... a这里的a其实相当于一个数组，可以通过遍历得到每一个参数

15.Throwable error-->例如内存溢出 、Exception-->RuntimeException
处理方法-->try{}catch(异常名 变量 ){必须有内容}可以多catch但是父子关系，父必须放在后面，Catch内的异常也可以是多个但是必须同级 e.toString e.getMessage()可以帮助我们了解错误类型finally{}    final、finally和finalize的区别？ final是关键字可以修饰成员变量(常量)、成员方法(不能被重写)、类(不能被继承),finally是释放资源，除非未执行到finallyJVM推出不然肯定执行，如果在catch中有return那么肯定执行finally在return 之前,finalize用于垃圾回收
	-->throws 与throw区别  throws用在方法声明之后，可以是多个方法类名；throw方法体重，一旦使用一定抛出异常
自定义Exception需要继承Exception或者RuntimeException ,子类重写父类，子类方法只能抛出和父类一样或者其子类的异常

16.File
File(String pathname)、File(parentpath,path)、File(File,chilepath) 注意这里的String的\符号都需要\\转译过去
File.createFile()如果存在这样的文件不会创建该文件  mkdir()创建文件夹，如果存在不创建  mkdirs()如果父文件夹不存在会帮你创建，如果不写父文件夹默认是项目文件夹  删除delete文件夹中不能有东西，且不走回收站  重命名renameTo(File dest)如果路径相同为重命名，如果路径不同为剪切
getPath()得到相对路径  getAbsolutePath()得到绝对路径 getModified()获取最后修改时间 list()获得所有的文件及文件夹的名字string[]  获得文件File[]用listFiles(new FilenameFilter(){accept方法})里卖弄可以写匿名内部类过滤文件

17.递归
递归一定要有出口不然为死递归，递归太多容易内存溢出，构造方法不能递归使用;递归删除，递归得到文件名，递归树

18.IO 主动，输出即写，读取即读;注意流的回收一般在try catch finally中的finally中执行.close()
-->字节流 OutputStream InputStream 
	--》 xxxOutputStream(File.、Buffered.高效) ..实现上面的抽象类的子类xxx对应的是操作对象,例如File writer(xxx)注意里面是字节会自动转换 其中的换行操作同样需要.getBytes()转换成字节，Windows为\r\n linux为\n mac为\r;操作中文会出乱码;指定编码和解码的类型 InputStreamReader(new FileInputStream(""),"UTF-8")
	--》xxxInputStream byte[] bys = new byte[]; int len =0; while((len = fis.read(bys))!=-1) {System.out.println(new String(bys,0,len))} fis.close();
	--》DataInputStream(InputStream in)数据输入流一般保存位.dat文件和文本文件区分开来
	
-->字符流        Writer    Reader
	--》OutputStreamWriter write(int char[] char[],0,len String String,0,n) 注意在写的时候需要flush()刷新缓存区才能写到;flush()和close()的区别:flush只是刷新缓存区，刷新后的流对象还可以继续使用，而close()方法先刷新缓冲区再关闭流对象，不能使用
	--》InputStreamReader char[] chs = new char[1024];
	--》FIleReader = FileInputStream + 编码表(GBK)
	--》BufferedWriter new BufferedWriter(new FileWriter("path"));
	--》BufferedReader 除了char[] chs = new char[1024];还有读取的特殊方法newline()根据系统换行符string line = null;while((BUfferedReader.readLine())!=-1){}
		--》LineNumberReader getLineNumber()获得当前行号  setLineNumber(int lineNumber)
	
	注意BufferedWriter和BufferedReader在读写或者写读的时候创建对象需要分开用的时候在创建

-->内存操作流:用于存储临时操作信息 --》字节数组ByteArrayInputStream 不需要释放资源;字符数组CharArrayReader;字符串StringReader
-->打印流 PrintStream字节打印流 PrintWriter字符打印流  只能写不能读，可以开启自刷
-->随机访问流 RandomAccessFile(pathname,"rw") 这里的rw位置有4中选项;rw表示可读可写 getFilePointer文件指针位置 seek(int)设置到哪个位置
-->ObjectOutputStream是对象P到流数据(序列化流)      ObjectInputStream是流数据到对象(反序列化流)  都实现了Serializable接口(会出现黄色的线，需要在类中加入一个序列化id值)
println()--> bw.writer() bw.readLine() bw.flush()
一般的流的构造方法里有File和String一般可以操作文本文件
复制数据，如果我们知道用记事本打开并能够读懂，就用字符流，否则用字节流
a.txt+b.txt -- c.txt SequenceInputStream(Enumeration<InputStream> en); InputStream s1 s2 s3; Enumeration<InputStream> = v.elements(); v.add(s1)..;Vector<InputStream> v;
Properties 是一个Map集合 set/getProperty stringPropertyNames获取所有键的集合     ;store(Writer writer,String comments)将集合中的数据存储在文件中 ;load(Reader r(""))这里的文件中的内容必须是键值对的形式
IO流是阻塞的例如一个线程调用read或者write需要完全写入或者读取才能继续


19.NIO IO面对流，NIO面向缓冲区，NIO为非阻塞
http://www.importnew.com/19816.html
Channel 
-->FileChannel  IO FileChannel fileChannel = IO.getChannel()
-->DatagramChannel UDP 发送和接受的是包
-->SocketChannel TCP(server和client) channel.configureBlocking(false)返回值表明所请求操作完成的进度,如ServerSocketChannel调用accept()如果有连接请求返回SocketChannel否则返回null
client
打开:socketChannel = SocketChannel.open();socketChannel.connect(new InetSocketAddress("ip",8080))
关闭:socketChannel.close()
读取中:非阻塞模式下read()可能为读取数据就返回所以需要关注返回的值int表示读取的字节

-->ServerSocketChannel
server
打开:ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
关闭:serverSocketChannel.close()
监听新进来的连接:while(true) { SocketChannel socketChannel = serverSocketChannel.accept();} serverSocketChannel可以设置非阻塞的，所以在accept()会立即返回如果没有新进来的连接返回的是null ;后面加判断if(!socketChannel=null) {}

Buffer
-->每一个基本数据类型对应一个Buffer例如FloatBuffer 1.分配空间ByteBuffer buf = ByteBuffer.allocate(1024) 2.写入到buffer int bytesRead = fileChannel.read(buf) 3.调用filp方法buf.flip() 4.从Buffer读取数据buf.get()5.调用clear()(position=0,limit=capacity-->position=n,..-filp()->position=0,limit=n-clear()->初始)或者compact()Buffer有未读取数据的时候将未读取数据方法哦Buffer起始处，position=未读取数据末+1，这样Buffer准备好写入数据而不会覆盖未读取的数据
	从Channel写入Buffer:fileChannel.read(buf) buf.put();从Buffer读取到Channel channel.write(buf) 从Buffer中读取buf.get()	
-->MappedByteBuffer...

Selector
创建:Selector selector = Selector.open();
注册(使channel和Selector配合): ssc = serverSocketChannel.open();这里的ssc必须是非阻塞的才能和Selector配合由于FileChannel不能切换到非阻塞模式，所以无法和Selector一起使用 ssc.socket().bind(new InetSocketAddress(PORT));ssc.configureBlocking(false);ssc.register(selector, SelectionKey.OP_ACCEPT#这个参数表明Selector监听Channel对于什么事件感兴趣Connect(连接就绪)、Accept(接受就绪)、Read、Writer,theObject#附加对象);
	regist()返回的是SelectionKey对象，包含interest集合、ready集合int readySet = selectionKey.readyOps();可以得到什么事件准备好，也可以单独SelectionKey.isAcceptable()、SelectionKey访问Channel或Selector selectionKey.channel()
通过Selector选择通道:
注册了通道后，执行select()方法:select()阻塞到至少一个通道在注册的事件就就绪了，返回的是有多少通道就绪，但不包括上次的 select(long timeout)最长会阻塞这么长毫秒 selectNow()不会阻塞，没有准备好的通道返回0 返回的是感兴趣事件已经准备好的通道
selector.selectionKeys().iterator()返回一个迭代对象 Iterator<SelectionKey> 在迭代这个对象例如while(true) {注意每一次迭代末尾的 iter.remove()因为Selector不会自己将已选择的键集从SelectKeys移除}
selectionKey.channel()返回的通道需要转换成你需要的类型如ServerSocketChannel

数据由通道(Channel类似于Stream但是是双向的)读取到缓冲区(如果目前没有可用的数据不会保存线程阻塞,写也是同理)，Selector(选择区)选择通道

Java处理大文件一般使用BufferedReader或者BufferedInputStream这种带有缓冲的IO类，文件超大使用MapperByteBuffer
select模型:将套接字通道(SocketChannel)注册到一个选择器Selector中，不时调用选择器的select方法返回满足的选择键SelectionKey
SocketChannel读写通过ByteBuffer 直接:HeapByteBuffer直接操作堆内存但是对于大文件不好使 间接:MappedByteBuffer将文件映射到虚拟内存而不是物理内存 fileChannel.map(int mode（可访问内存映像文件的方式MapMode.READ_ONLY,READ_WRITE,PRIVATE（专用）修改会创建副本）,long position,long size) force()在RW模式下强行写入文件  load()将缓冲区文件写入内存 isLoader()缓冲区文件是否在内存中

Scatter\Gatter 从Channel读取写入多个Buffer用Scatter Gatter将多个Buffer写入一个Channel
transferFrom可以将数据从源通道反传输到FileChannel中 transferTo将数据从FileChannel传输到其他通道中
 Pipe有一个source通道和一个sink通道，数据将会由source写道sink通道中  Pipe.SourceChannel sourceChannel = pipeTemp.source();//向通道中读数据

同步与异步，阻塞和非阻塞？
同步synchronous-->阻塞 调用发出后只有得到返回，自己才返回
异步asynchronous-->非阻塞 调用发出后不反悔就自己返回

多线程一般使用线程池可以让线程的创建和回收成本较低,但是线程创建成本高，占用内存大，线程切换成本偏高，在连接数很大的时候就需要抛弃BIO(Blocking)
在BIO中socket.read()如果TCP RecvBuffer中没有数据，会一直阻塞而对于NIO如果有数据会将数据由网卡读取到内存中，如果没有数据返回0不会阻塞；而AIO是网卡到内存过程也是异步的
在NIO中线程主要:1.时间分发器，单线程选择时间 2.I/O处理器 包括connect、read、write 3.业务线程一般有自己的业务逻辑当然还可能有其他阻塞IO如 DB操作、RPC等
对于Redis，对于Redis来说，由于服务端是全局串行的，能够保证同一连接的所有请求与返回顺序一致。这样可以使用单线程＋队列，把请求数据缓冲。然后pipeline发送，返回future，然后channel可读时，直接在队列中把future取回来，done()就可以了


20.Thread线程
一个进程里可能有多个线程，并行parallelise指的是具有多种处理事件的能力但不一定是同时的;并发concurrency是同时处理多种事件
自己写的线程需要继承Thread然后重写run()方法，注意和start()的区别,run只执行其中的内容，而start启动了JVM线程去调用该线程的run方法
thread.setPriority(int a)可以设置优先级默认为5 范围为1-10;thread.sleep(int a)线程休眠;thread.setDaemon(true)守护线程，需在start之前调用
